# Технический анализ системы карты

## Обзор архитектуры

Система карты построена на базе **Mapbox GL JS** с использованием React и Convex в качестве бэкенда. Архитектура следует принципам **Feature-Sliced Design (FSD)** и разделена на несколько слоёв:

### Структура компонентов

```
src/
├── pages/MapPage.tsx              # Главная страница карты
├── widgets/map/                   # Виджеты карты
│   └── map-view/
│       ├── MapView.tsx            # Основной компонент карты
│       ├── MapMarkers.tsx         # Управление маркерами
│       ├── MapPopups.tsx          # Управление попапами
│       ├── SafeZonesControl.ts    # Контрол безопасных зон
│       ├── FogOfWarLayer.tsx      # Слой тумана войны
│       └── ...
├── entities/map-point/            # Сущности точек карты
│   └── ui/
│       ├── MapPointMarker.tsx    # Компонент маркера
│       └── MapPointPopup.tsx      # Компонент попапа
├── features/map/                  # Фичи карты
│   ├── hooks/useFogOfWar.ts      # Хук тумана войны
│   └── lib/resolveSceneBinding.ts # Разрешение сцен
└── shared/
    ├── ui/MapboxMap.tsx          # Обёртка Mapbox
    └── hooks/useMapData.ts       # Хуки данных карты
```

---

## 1. Бэкенд (Convex)

### 1.1 Схема данных

**Таблица `map_points`** (`convex/schema.ts:81-109`):
- Основные поля: `id`, `title`, `description`, `coordinates`, `type`, `phase`, `isActive`
- Метаданные: `metadata` (JSON) содержит `danger_level`, `faction`, `sceneBindings`, `unlockRequirements`, `qrRequired`
- Индексы: по `id`, координатам, `qrCode`, типу, фазе, активности

**Таблица `point_discoveries`** (`convex/schema.ts:143-155`):
- Отслеживает состояние открытия точек для каждого игрока
- Поля: `deviceId`/`userId`, `pointKey`, `discoveredAt`, `researchedAt`
- Индексы: по устройству/пользователю, точке, комбинированные

**Таблица `safe_zones`** и `danger_zones`:
- Хранят полигоны зон безопасности и опасности
- Используются для визуализации на карте

### 1.2 API функции

#### `mapPoints.listVisible` (`convex/mapPoints.ts:50-261`)
**Назначение**: Получение видимых точек карты с учётом прогресса игрока

**Логика работы**:
1. Получение флагов и фазы игрока из `game_progress`
2. Определение активных квестов из `quest_progress`
3. Фильтрация точек по:
   - Фазе игры (`phase`)
   - Границам видимости (`bbox`)
   - Требованиям разблокировки (`unlockRequirements`)
4. Обогащение точек статусом открытия из `point_discoveries`
5. Помечение целей активных квестов (`isActiveQuestTarget`)

**Проблемы и улучшения**:
- ⚠️ **Производительность**: Фильтрация по `bbox` происходит в памяти после загрузки всех точек (`take(limit * 2)`)
  - **Рекомендация**: Использовать пространственные индексы Convex или предварительную фильтрацию на уровне БД
- ⚠️ **N+1 запросы**: Для каждой точки выполняется отдельный запрос `point_discoveries`
  - **Рекомендация**: Использовать `Promise.all` с батчингом или джойны

#### `mapPoints.activateByQR` (`convex/mapPoints.ts:545-648`)
**Назначение**: Активация точки через QR-код

**Логика**:
1. Поиск точки по QR-коду (с индексом `by_qr_code`)
2. Создание/обновление записи в `point_discoveries`
3. Начисление опыта на основе `danger_level` (50/75/125 XP)
4. Обновление `game_progress` с учётом повышения уровня

**Проблемы**:
- ✅ Хорошо: Используется индекс для поиска QR
- ⚠️ **Дублирование логики**: Похожая логика в `markResearched` - можно вынести в общую функцию

#### `mapPoints.discoverByProximity` (`convex/mapPoints.ts:436-503`)
**Назначение**: Автоматическое открытие точек при приближении игрока

**Логика**:
- Вычисление расстояния по формуле Haversine
- Радиус по умолчанию: 75 метров
- Создание записей `discoveredAt` без `researchedAt` (без начисления XP)

**Проблемы**:
- ⚠️ **Производительность**: Загружаются все активные точки (`take(1000)`), затем фильтрация в памяти
  - **Рекомендация**: Использовать пространственные запросы или предварительную фильтрацию по `bbox`

---

## 2. Фронтенд - Компоненты

### 2.1 MapboxMap (`src/shared/ui/MapboxMap.tsx`)

**Назначение**: Базовая обёртка для Mapbox GL JS

**Особенности**:
- ✅ Fallback на Carto Dark Matter при отсутствии токена Mapbox
- ✅ Обработка ошибок загрузки стиля
- ✅ Контролы навигации, геолокации, масштаба
- ✅ Слушатели событий `moveend` и `zoom`

**Проблемы**:
- ⚠️ **Обновление центра**: Используется `jumpTo` вместо `flyTo` - резкий переход
  - **Рекомендация**: Добавить параметр `smooth` для плавной анимации
- ⚠️ **Очистка**: Слушатели событий удаляются только при размонтировании, но не при изменении пропсов

### 2.2 MapView (`src/widgets/map/map-view/MapView.tsx`)

**Назначение**: Главный компонент карты, координирует все слои

**Архитектура**:
- Использует композицию компонентов: `MapMarkers`, `MapPopups`, `FogOfWarLayer`, `DangerZonesLayer`, `FactionZonesLayer`
- Управляет состоянием: `selectedPointId`, `bbox`, `navigationTarget`
- Интегрирует хуки: `useVisibleMapPoints`, `useSafeZones`, `useGeolocation`

**Проблемы**:
- ⚠️ **Автооткрытие точек**: `discoverByProximity` вызывается каждые 15 секунд при наличии геолокации
  - **Рекомендация**: Добавить проверку реального перемещения игрока перед вызовом
- ⚠️ **Фильтрация точек**: Простая фильтрация по типу в `useMemo` - можно оптимизировать
- ✅ Хорошо: Используется `useCallback` для обработчиков событий

### 2.3 MapMarkers (`src/widgets/map/map-view/MapMarkers.tsx`)

**Назначение**: Управление маркерами точек на карте

**Архитектура**:
- Использует `mapboxgl.Marker` с React-контентом через `createRoot`
- Хранит ссылки на маркеры в `Map<string, { marker, root }>`
- Обновляет только изменённые маркеры, удаляет отсутствующие

**Проблемы**:
- ✅ Хорошо: Правильная очистка через `queueMicrotask` для избежания гонок
- ⚠️ **Производительность**: При большом количестве точек (>100) возможны лаги при обновлении
  - **Рекомендация**: Использовать виртуализацию или кластеризацию маркеров
- ⚠️ **Обновление координат**: При изменении координат точки маркер перемещается, но без анимации
  - **Рекомендация**: Добавить плавное перемещение для улучшения UX

### 2.4 MapPopups (`src/widgets/map/map-view/MapPopups.tsx`)

**Назначение**: Управление попапами и тултипами точек

**Архитектура**:
- Разделение на `popup` (выбранная точка) и `tooltip` (наведение)
- Использует `mapboxgl.Popup` с React-контентом
- Обновляет контент через `root.render` без пересоздания попапа

**Проблемы**:
- ⚠️ **Tooltip**: Использует `innerHTML` вместо React - потенциальная XSS-уязвимость
  - **Рекомендация**: Использовать React-компонент для tooltip
- ✅ Хорошо: Правильная обработка cleanup через `queueMicrotask`

### 2.5 MapPointMarker (`src/entities/map-point/ui/MapPointMarker.tsx`)

**Назначение**: Визуальное представление маркера точки

**Особенности**:
- Динамический выбор иконки по типу и фракции
- Цветовая схема по фракциям (FJR, Artisans, Synthesis и т.д.)
- Пульсирующая анимация для целей квестов
- Индикаторы опасности и QR-требований

**Проблемы**:
- ✅ Хорошо: Используется `lucide-react` для иконок - консистентный дизайн
- ⚠️ **Производительность**: Анимация `animate-ping` может быть тяжёлой при множестве маркеров
  - **Рекомендация**: Отключать анимацию при низком зуме или использовать CSS `will-change`

### 2.6 MapPointPopup (`src/entities/map-point/ui/MapPointPopup.tsx`)

**Назначение**: Попап с информацией о точке и действиями

**Особенности**:
- Отображение метаданных: статус, опасность, фракция
- Интеграция с `useMapPointInteraction` для действий
- Градиентный заголовок по фракции
- Кнопки: Навигация, Взаимодействие, Сканирование QR

**Проблемы**:
- ⚠️ **Валидация расстояния**: Проверка `distance > 0.05` (50м) - жёстко закодировано
  - **Рекомендация**: Вынести в конфигурацию или метаданные точки
- ✅ Хорошо: Используется `InteractionMenu` для гибких действий

---

## 3. Хуки и утилиты

### 3.1 useVisibleMapPoints (`src/shared/hooks/useMapData.ts:16-98`)

**Назначение**: Загрузка видимых точек карты

**Особенности**:
- Кэширование результатов с TTL (5 минут)
- Обработка отмены запросов при размонтировании
- Логирование для отладки

**Проблемы**:
- ⚠️ **Кэширование**: TTL задан на сервере, но клиент не использует его эффективно
  - **Рекомендация**: Реализовать клиентский кэш с проверкой TTL
- ⚠️ **Зависимости**: `useMemo` для `queryArgs` может вызывать лишние запросы при изменении объекта `bbox`
  - **Рекомендация**: Использовать глубокое сравнение или сериализацию

### 3.2 useGeolocation (`src/shared/hooks/useMapData.ts:178-264`)

**Назначение**: Получение геолокации пользователя

**Особенности**:
- Поддержка режимов `watch` и одноразового запроса
- Настройка точности (`high`/`low`)
- Обработка ошибок

**Проблемы**:
- ⚠️ **Таймаут**: Жёстко задан `timeout: 10000` - может быть недостаточно для медленных устройств
  - **Рекомендация**: Сделать настраиваемым параметром
- ✅ Хорошо: Правильная очистка `watchPosition` при размонтировании

### 3.3 useFogOfWar (`src/features/map/hooks/useFogOfWar.ts`)

**Назначение**: Вычисление маски тумана войны

**Особенности**:
- Использует библиотеку `@turf/turf` для геопространственных операций
- Объединяет области открытых точек и позицию игрока
- Оптимизация: обновление только при перемещении >10м

**Проблемы**:
- ⚠️ **Производительность**: Операции `turf.union` и `turf.difference` могут быть тяжёлыми при большом количестве точек
  - **Рекомендация**: Использовать Web Workers для вычислений или упростить алгоритм
- ⚠️ **Типы**: Используются `@ts-expect-error` для обхода проблем типизации Turf.js
  - **Рекомендация**: Создать обёртки с правильными типами

---

## 4. Интеграция с игровыми системами

### 4.1 Разрешение сцен (`src/features/map/lib/resolveSceneBinding.ts`)

**Назначение**: Определение доступной сцены для точки на основе прогресса игрока

**Логика**:
1. Сортировка `sceneBindings` по приоритету
2. Проверка условий: флаги, фаза, квесты, уровень, репутация
3. Возврат первой подходящей сцены

**Проблемы**:
- ✅ Хорошо: Гибкая система условий с приоритетами
- ⚠️ **Производительность**: Проверка всех условий для каждого биндинга может быть оптимизирована
  - **Рекомендация**: Кэшировать результаты проверки условий

### 4.2 QR-сканирование (`src/pages/MapPage.tsx:119-148`)

**Назначение**: Активация точек через QR-код

**Поток**:
1. Пользователь нажимает "Сканировать QR"
2. Открывается компонент `QRPointActivation`
3. При успешном сканировании вызывается `mapPoints.activateByQR`
4. Обновление UI с уведомлением

**Проблемы**:
- ⚠️ **Обработка ошибок**: Общие сообщения об ошибках - можно улучшить
  - **Рекомендация**: Специфичные сообщения для разных типов ошибок (неверный QR, сеть, точка уже открыта)

---

## 5. Производительность

### 5.1 Проблемы производительности

1. **Загрузка точек**:
   - Загружаются все точки, затем фильтрация по `bbox` в памяти
   - **Решение**: Использовать пространственные индексы или предварительную фильтрацию

2. **Обновление маркеров**:
   - При изменении `selectedPointId` перерисовываются все маркеры
   - **Решение**: Использовать `React.memo` для `MapPointMarker` или оптимизировать обновления

3. **Туман войны**:
   - Вычисления `turf.union` и `turf.difference` синхронны и блокируют UI
   - **Решение**: Вынести в Web Worker или упростить алгоритм

4. **N+1 запросы**:
   - Для каждой точки отдельный запрос `point_discoveries`
   - **Решение**: Батчинг запросов или джойны

### 5.2 Оптимизации

✅ **Уже реализовано**:
- Кэширование результатов запросов (TTL 5 минут)
- Дебаунсинг обновлений `bbox`
- Оптимизация обновлений тумана войны (только при перемещении >10м)
- Правильная очистка ресурсов через `queueMicrotask`

---

## 6. Безопасность

### 6.1 Проблемы безопасности

1. **XSS в tooltip** (`MapPopups.tsx:72-76`):
   - Использование `innerHTML` с данными пользователя
   - **Решение**: Использовать React-компонент или санитизацию

2. **Валидация QR-кодов**:
   - Проверка на сервере есть, но можно улучшить валидацию формата
   - **Рекомендация**: Добавить проверку формата QR-кода перед запросом к БД

3. **Геолокация**:
   - Нет ограничений на частоту запросов `discoverByProximity`
   - **Рекомендация**: Добавить rate limiting на клиенте и сервере

---

## 7. Типизация

### 7.1 Проблемы типизации

1. **Метаданные точек**:
   - Используется `v.any()` в схеме Convex
   - **Рекомендация**: Создать строгие типы для `MapPointMetadata`

2. **Turf.js типы**:
   - Используются `@ts-expect-error` для обхода проблем типизации
   - **Рекомендация**: Создать обёртки с правильными типами

3. **Условные типы**:
   - Некоторые функции используют `as any` для обхода проверок
   - **Рекомендация**: Улучшить типизацию или использовать type guards

---

## 8. Рекомендации по улучшению

### 8.1 Критичные

1. **Оптимизация загрузки точек**:
   - Использовать пространственные индексы Convex
   - Предварительная фильтрация по `bbox` на уровне БД

2. **Исправление XSS**:
   - Заменить `innerHTML` на React-компонент в tooltip

3. **Оптимизация N+1**:
   - Батчинг запросов `point_discoveries`

### 8.2 Важные

1. **Производительность маркеров**:
   - Виртуализация или кластеризация при большом количестве точек
   - Использование `React.memo` для `MapPointMarker`

2. **Туман войны**:
   - Вынести вычисления в Web Worker
   - Упростить алгоритм для лучшей производительности

3. **Улучшение UX**:
   - Плавные переходы при изменении центра карты
   - Анимация перемещения маркеров

### 8.3 Желательные

1. **Кэширование**:
   - Клиентский кэш с проверкой TTL
   - Оптимизация зависимостей `useMemo`

2. **Типизация**:
   - Строгие типы для метаданных
   - Обёртки для Turf.js

3. **Обработка ошибок**:
   - Специфичные сообщения об ошибках
   - Retry логика для сетевых запросов

---

## 9. Архитектурные решения

### 9.1 Сильные стороны

✅ **Модульность**: Чёткое разделение на слои (entities, features, widgets)
✅ **Переиспользование**: Хуки и утилиты вынесены в `shared`
✅ **Типобезопасность**: Использование TypeScript и типов Convex
✅ **Обработка ошибок**: Try-catch блоки и graceful degradation
✅ **Очистка ресурсов**: Правильная очистка слушателей и React-корней

### 9.2 Области для улучшения

⚠️ **Производительность**: Оптимизация запросов и рендеринга
⚠️ **Безопасность**: Исправление XSS и улучшение валидации
⚠️ **Типизация**: Устранение `any` и улучшение типов
⚠️ **Тестирование**: Отсутствие unit-тестов для критичных компонентов

---

## 10. Заключение

Система карты имеет **хорошую архитектуру** и следует лучшим практикам React и Mapbox GL JS. Основные проблемы связаны с **производительностью** (загрузка точек, обновление маркеров, туман войны) и **безопасностью** (XSS в tooltip).

**Приоритеты для улучшения**:
1. Оптимизация загрузки точек (пространственные индексы)
2. Исправление XSS в tooltip
3. Оптимизация N+1 запросов
4. Вынос вычислений тумана войны в Web Worker
5. Виртуализация/кластеризация маркеров

Система готова к использованию, но требует оптимизации для масштабирования на большое количество точек и пользователей.






